<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InspIRCd: ModuleSpanningTree Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ModuleSpanningTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="main_8h_source.html">main.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ModuleSpanningTree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_module_spanning_tree.png" usemap="#ModuleSpanningTree_map" alt=""/>
  <map id="ModuleSpanningTree_map" name="ModuleSpanningTree_map">
<area href="class_module.html" alt="Module" shape="rect" coords="71,56,204,80"/>
<area href="classclassbase.html" alt="classbase" shape="rect" coords="0,0,133,24"/>
<area href="classusecountbase.html" alt="usecountbase" shape="rect" coords="143,0,276,24"/>
</map>
 </div></div>

<p><a href="class_module_spanning_tree-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a81fd0204eb915765b6162c7b42378324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a81fd0204eb915765b6162c7b42378324">ModuleSpanningTree</a> ()</td></tr>
<tr class="memitem:ab48b2a66f23fd6bd87aa1c07ef3d6e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ab48b2a66f23fd6bd87aa1c07ef3d6e74">ReadConfig</a> (<a class="el" href="class_config_read_status.html">ConfigReadStatus</a> &amp;)</td></tr>
<tr class="memitem:a450402b81db47b1d4bc5cb3a1110b056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a450402b81db47b1d4bc5cb3a1110b056">init</a> ()</td></tr>
<tr class="memitem:af5a03a072da6682bcee388c0381edcf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af5a03a072da6682bcee388c0381edcf8">ShowLinks</a> (<a class="el" href="class_tree_server.html">TreeServer</a> *Current, <a class="el" href="class_user.html">User</a> *user, int hops)</td></tr>
<tr class="memitem:ac5eda456bff949bd8d04ded76ccdbcec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ac5eda456bff949bd8d04ded76ccdbcec">CountServs</a> ()</td></tr>
<tr class="memitem:a2499c417f6c3a55a26285505be25dbbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a2499c417f6c3a55a26285505be25dbbd">HandleLinks</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:ae251705b9e9f4eae2e7c5cec1be59913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ae251705b9e9f4eae2e7c5cec1be59913">ShowMap</a> (<a class="el" href="class_tree_server.html">TreeServer</a> *Current, <a class="el" href="class_user.html">User</a> *user, int depth, int &amp;line, char *names, int &amp;maxnamew, char *stats)</td></tr>
<tr class="memitem:adf9e7958dac78d97ff966e18272e0467"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#adf9e7958dac78d97ff966e18272e0467">HandleMap</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:addb66eaba37f614fbe85d5367343fdcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#addb66eaba37f614fbe85d5367343fdcb">HandleSquit</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a3b1cd65454f08331bbab20241c9149d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a3b1cd65454f08331bbab20241c9149d7">HandleRemoteWhois</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:af3a127376d84603d96587f6037568b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af3a127376d84603d96587f6037568b84">ConnectServer</a> (<a class="el" href="class_link.html">Link</a> *x, <a class="el" href="class_autoconnect.html">Autoconnect</a> *y=NULL)</td></tr>
<tr class="memitem:af2a28dbc21df9a7e11426edc1bd0549e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af2a28dbc21df9a7e11426edc1bd0549e">ConnectServer</a> (<a class="el" href="class_autoconnect.html">Autoconnect</a> *y, bool on_timer)</td></tr>
<tr class="memitem:a03b74a2a95d120c9a3cbc25273bcba20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a03b74a2a95d120c9a3cbc25273bcba20">HandleVersion</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a13fe5f715081953c7b0e18a7fb2bfdb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a13fe5f715081953c7b0e18a7fb2bfdb5">HandleConnect</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a711fba96019a9a27b0858d94afe5ea7f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a711fba96019a9a27b0858d94afe5ea7f">MapOperInfo</a> (<a class="el" href="class_tree_server.html">TreeServer</a> *Current)</td></tr>
<tr class="memitem:af46c2f0ec066859a3245610a19ddcb34"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af46c2f0ec066859a3245610a19ddcb34">TimeToStr</a> (time_t secs)</td></tr>
<tr class="memitem:a186d18c39ac2a022a79f7833150ea150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a186d18c39ac2a022a79f7833150ea150">OnPreCommand</a> (std::string &amp;command, std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user, bool validated, const std::string &amp;original_line)</td></tr>
<tr class="memitem:a76c097965b919eb655c10d00f3d3860a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a76c097965b919eb655c10d00f3d3860a">OnPostCommand</a> (const std::string &amp;command, const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user, CmdResult result, const std::string &amp;original_line)</td></tr>
<tr class="memitem:a04cdfa23fcbbd8300eb8c76bad5087e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a04cdfa23fcbbd8300eb8c76bad5087e6">OnGetServerDescription</a> (const std::string &amp;servername, std::string &amp;description)</td></tr>
<tr class="memitem:a264f10a18eb1c06f8fda1e417d28a02b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a264f10a18eb1c06f8fda1e417d28a02b">OnUserConnect</a> (<a class="el" href="class_local_user.html">LocalUser</a> *source)</td></tr>
<tr class="memitem:ac55ca4b72d767729350834874535bd0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ac55ca4b72d767729350834874535bd0b">OnUserInvite</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, time_t)</td></tr>
<tr class="memitem:aeaad217ca3f56a7019bf6d4e30d9a7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#aeaad217ca3f56a7019bf6d4e30d9a7f6">OnPostTopicChange</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;topic)</td></tr>
<tr class="memitem:af8a2bb4fd3cb1b810e56ec06c1865cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af8a2bb4fd3cb1b810e56ec06c1865cd1">OnWallops</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;text)</td></tr>
<tr class="memitem:a7048e3f4fdd4fe06cb6acae812245d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a7048e3f4fdd4fe06cb6acae812245d86">OnUserNotice</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::string &amp;text, char status, const CUList &amp;exempt_list)</td></tr>
<tr class="memitem:aa5f1a1093fda34e0e777a4a4d64bf78b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#aa5f1a1093fda34e0e777a4a4d64bf78b">OnUserMessage</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::string &amp;text, char status, const CUList &amp;exempt_list)</td></tr>
<tr class="memitem:a921129aba53cdcf25497ecb0d55ff057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a921129aba53cdcf25497ecb0d55ff057">OnBackgroundTimer</a> (time_t curtime)</td></tr>
<tr class="memitem:a6b3c027470ceb44bfe8920ff8ba75f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a6b3c027470ceb44bfe8920ff8ba75f13">OnUserJoin</a> (<a class="el" href="class_membership.html">Membership</a> *memb, bool sync, bool created, CUList &amp;excepts)</td></tr>
<tr class="memitem:a7059dff0c2b341ecf852c7a5f3dd0a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a7059dff0c2b341ecf852c7a5f3dd0a95">OnChangeHost</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="memitem:a6d8bee42aeac03319ed27a1d5e89596c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a6d8bee42aeac03319ed27a1d5e89596c">OnChangeName</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;gecos)</td></tr>
<tr class="memitem:a380ed9f27f93fcd7b923958bf8e379ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a380ed9f27f93fcd7b923958bf8e379ae">OnChangeIdent</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;ident)</td></tr>
<tr class="memitem:a0d13bb14dec8357a2e99e31f0402b9fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a0d13bb14dec8357a2e99e31f0402b9fd">OnUserPart</a> (<a class="el" href="class_membership.html">Membership</a> *memb, std::string &amp;partmessage, CUList &amp;excepts)</td></tr>
<tr class="memitem:acbafe4fcda429c26bcc54dbea536dad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#acbafe4fcda429c26bcc54dbea536dad4">OnUserQuit</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;reason, const std::string &amp;oper_message)</td></tr>
<tr class="memitem:ac2e9651f46a462c7c49fe867085219ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ac2e9651f46a462c7c49fe867085219ea">OnUserPostNick</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;oldnick)</td></tr>
<tr class="memitem:ae17174311377f47da9f4e74ec6d1f70c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ae17174311377f47da9f4e74ec6d1f70c">OnUserKick</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_membership.html">Membership</a> *memb, const std::string &amp;reason, CUList &amp;excepts)</td></tr>
<tr class="memitem:ad4f8459faea3633f5f02d38b5945095e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ad4f8459faea3633f5f02d38b5945095e">OnRemoteKill</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, const std::string &amp;reason, const std::string &amp;operreason)</td></tr>
<tr class="memitem:a1a293c7afc04ffadebfb1647210a4d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a1a293c7afc04ffadebfb1647210a4d38">OnOper</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;opertype)</td></tr>
<tr class="memitem:ae89c8415aacee53fcea3b606c871a195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae89c8415aacee53fcea3b606c871a195"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>OnLine</b> (<a class="el" href="class_user.html">User</a> *source, const std::string &amp;host, bool adding, char linetype, long duration, const std::string &amp;reason)</td></tr>
<tr class="memitem:a2fe58bf526042bf4d5c9078bdda95c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a2fe58bf526042bf4d5c9078bdda95c17">OnAddLine</a> (<a class="el" href="class_user.html">User</a> *u, <a class="el" href="class_x_line.html">XLine</a> *x)</td></tr>
<tr class="memitem:a8f2bde1c0b1c6895d945b9ce4b3c2c5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a8f2bde1c0b1c6895d945b9ce4b3c2c5f">OnDelLine</a> (<a class="el" href="class_user.html">User</a> *u, <a class="el" href="class_x_line.html">XLine</a> *x)</td></tr>
<tr class="memitem:aa853f28ec65cce1f74f69c68fa4596ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#aa853f28ec65cce1f74f69c68fa4596ff">OnStats</a> (char statschar, <a class="el" href="class_user.html">User</a> *user, string_list &amp;results)</td></tr>
<tr class="memitem:ada33998b7616a2c5f4d99fac47302c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ada33998b7616a2c5f4d99fac47302c17">OnSetAway</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;awaymsg)</td></tr>
<tr class="memitem:a531e6972fae55a007174f6ede3203521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a531e6972fae55a007174f6ede3203521">OnLoadModule</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memitem:add64ad65a88310e30a23eac209cf7444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#add64ad65a88310e30a23eac209cf7444">OnUnloadModule</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memitem:aabd6022dc36d621c6194ac06a12e0362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_stream_socket.html">StreamSocket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#aabd6022dc36d621c6194ac06a12e0362">OnAcceptConnection</a> (int newsock, <a class="el" href="class_listen_socket.html">ListenSocket</a> *from, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *client, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *server)</td></tr>
<tr class="memitem:a45902839f2973017eae5643d27cbbda3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cull_result.html">CullResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a45902839f2973017eae5643d27cbbda3">cull</a> ()</td></tr>
<tr class="memitem:abfc5b4c004319dae82f96560ea949018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#abfc5b4c004319dae82f96560ea949018">GetVersion</a> ()</td></tr>
<tr class="memitem:a58a8e3fba7cfeadda4b74a9524d640a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a8e3fba7cfeadda4b74a9524d640a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Prioritize</b> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab5817fb93fb5598ff76900df63883498"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5817fb93fb5598ff76900df63883498"></a>
<a class="el" href="class_spanning_tree_utilities.html">SpanningTreeUtilities</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Utils</b></td></tr>
<tr class="memitem:ab4e326e110785e7e8b86ccf073593ce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4e326e110785e7e8b86ccf073593ce5"></a>
<a class="el" href="class_cache_refresh_timer.html">CacheRefreshTimer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>RefreshTimer</b></td></tr>
<tr class="memitem:a3332c431147e5601e1b2634d6785d371"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a3332c431147e5601e1b2634d6785d371">loopCall</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is the main class for the spanningtree module </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a81fd0204eb915765b6162c7b42378324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_module_spanning_tree.html#a81fd0204eb915765b6162c7b42378324">ModuleSpanningTree::ModuleSpanningTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af3a127376d84603d96587f6037568b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#af3a127376d84603d96587f6037568b84">ModuleSpanningTree::ConnectServer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_autoconnect.html">Autoconnect</a> *&#160;</td>
          <td class="paramname"><em>y</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect a server locally </p>

</div>
</div>
<a class="anchor" id="af2a28dbc21df9a7e11426edc1bd0549e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#af3a127376d84603d96587f6037568b84">ModuleSpanningTree::ConnectServer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_autoconnect.html">Autoconnect</a> *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect the next autoconnect server </p>

</div>
</div>
<a class="anchor" id="ac5eda456bff949bd8d04ded76ccdbcec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_module_spanning_tree.html#ac5eda456bff949bd8d04ded76ccdbcec">ModuleSpanningTree::CountServs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Counts local and remote servers </p>

</div>
</div>
<a class="anchor" id="a45902839f2973017eae5643d27cbbda3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cull_result.html">CullResult</a> <a class="el" href="class_module_spanning_tree.html#a45902839f2973017eae5643d27cbbda3">ModuleSpanningTree::cull</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clean up prior to destruction If you override, you must call this AFTER your module's cleanup </p>

<p>Reimplemented from <a class="el" href="class_module.html#a9cf4e278594597a19264689a2d14bde0">Module</a>.</p>

</div>
</div>
<a class="anchor" id="abfc5b4c004319dae82f96560ea949018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_version.html">Version</a> <a class="el" href="class_module_spanning_tree.html#abfc5b4c004319dae82f96560ea949018">ModuleSpanningTree::GetVersion</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the version number of a <a class="el" href="class_module.html">Module</a>. The method should return a <a class="el" href="class_version.html">Version</a> object with its version information assigned via <a class="el" href="class_version.html#aaf3a196a2f6e05adc2dfb92844adcf73">Version::Version</a> </p>

<p>Implements <a class="el" href="class_module.html#ace1cba59ac54d26b4649858b2cfc6aa8">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a13fe5f715081953c7b0e18a7fb2bfdb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> <a class="el" href="class_module_spanning_tree.html#a13fe5f715081953c7b0e18a7fb2bfdb5">ModuleSpanningTree::HandleConnect</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle CONNECT </p>

</div>
</div>
<a class="anchor" id="a2499c417f6c3a55a26285505be25dbbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a2499c417f6c3a55a26285505be25dbbd">ModuleSpanningTree::HandleLinks</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle LINKS command </p>

</div>
</div>
<a class="anchor" id="adf9e7958dac78d97ff966e18272e0467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_module_spanning_tree.html#adf9e7958dac78d97ff966e18272e0467">ModuleSpanningTree::HandleMap</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle MAP command </p>

</div>
</div>
<a class="anchor" id="a3b1cd65454f08331bbab20241c9149d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> <a class="el" href="class_module_spanning_tree.html#a3b1cd65454f08331bbab20241c9149d7">ModuleSpanningTree::HandleRemoteWhois</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle remote WHOIS </p>

</div>
</div>
<a class="anchor" id="addb66eaba37f614fbe85d5367343fdcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> <a class="el" href="class_module_spanning_tree.html#addb66eaba37f614fbe85d5367343fdcb">ModuleSpanningTree::HandleSquit</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle SQUIT </p>

</div>
</div>
<a class="anchor" id="a03b74a2a95d120c9a3cbc25273bcba20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> <a class="el" href="class_module_spanning_tree.html#a03b74a2a95d120c9a3cbc25273bcba20">ModuleSpanningTree::HandleVersion</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle remote VERSON </p>

</div>
</div>
<a class="anchor" id="a450402b81db47b1d4bc5cb3a1110b056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a450402b81db47b1d4bc5cb3a1110b056">ModuleSpanningTree::init</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_module.html">Module</a> setup. Add the hooks you need here; without this, your module won't do anything. </p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_module_exception.html">ModuleException</a></td><td>Throwing this class, or any class derived from <a class="el" href="class_module_exception.html">ModuleException</a>, causes loading of the module to abort. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_module.html#a23abdbe5f94cf5311ea74d1f9a9e991b">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a711fba96019a9a27b0858d94afe5ea7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="class_module_spanning_tree.html#a711fba96019a9a27b0858d94afe5ea7f">ModuleSpanningTree::MapOperInfo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_server.html">TreeServer</a> *&#160;</td>
          <td class="paramname"><em>Current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns oper-specific MAP information </p>

</div>
</div>
<a class="anchor" id="aabd6022dc36d621c6194ac06a12e0362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_stream_socket.html">StreamSocket</a> * <a class="el" href="class_module_spanning_tree.html#aabd6022dc36d621c6194ac06a12e0362">ModuleSpanningTree::OnAcceptConnection</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_listen_socket.html">ListenSocket</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when a port accepts a connection Return MOD_RES_ACCEPT if you have used the file descriptor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor returned from accept() </td></tr>
    <tr><td class="paramname">from</td><td>The local port the user connected to </td></tr>
    <tr><td class="paramname">client</td><td>The client IP address and port </td></tr>
    <tr><td class="paramname">server</td><td>The server IP address and port </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#aedd601831e3eb3c6e0440c305a6d06ca">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a2fe58bf526042bf4d5c9078bdda95c17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a2fe58bf526042bf4d5c9078bdda95c17">ModuleSpanningTree::OnAddLine</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever an xline is added by a local user. This method is triggered after the line is added. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sender of the line or NULL for local server </td></tr>
    <tr><td class="paramname">line</td><td>The xline being added </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ace17c45466526ac93a24c8a7441b59e3">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a921129aba53cdcf25497ecb0d55ff057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a921129aba53cdcf25497ecb0d55ff057">ModuleSpanningTree::OnBackgroundTimer</a> </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>curtime</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called once every five seconds for background processing. This timer can be used to control timed features. Its period is not accurate enough to be used as a clock, but it is gauranteed to be called at least once in any five second period, directly from the main loop of the server. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">curtime</td><td>The current timer derived from time(2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a22aeb882a4a4cc619ebb7625ae241686">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a7059dff0c2b341ecf852c7a5f3dd0a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a7059dff0c2b341ecf852c7a5f3dd0a95">ModuleSpanningTree::OnChangeHost</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a user's hostname is changed. This event triggers after the host has been set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whos host is being changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new hostname being set </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a9f6aa4ebe19c22eb32f7a65ecbc74594">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a380ed9f27f93fcd7b923958bf8e379ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a380ed9f27f93fcd7b923958bf8e379ae">ModuleSpanningTree::OnChangeIdent</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ident</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a user's IDENT is changed. This event triggers after the name has been set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who's IDENT is being changed </td></tr>
    <tr><td class="paramname">gecos</td><td>The new IDENT being set on the user </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a135ab5a74a236dc4f696191b25efec2b">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a6d8bee42aeac03319ed27a1d5e89596c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a6d8bee42aeac03319ed27a1d5e89596c">ModuleSpanningTree::OnChangeName</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gecos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a user's GECOS (realname) is changed. This event triggers after the name has been set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who's GECOS is being changed </td></tr>
    <tr><td class="paramname">gecos</td><td>The new GECOS being set on the user </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a1d41b8806e963af21486007e5f8369c3">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a8f2bde1c0b1c6895d945b9ce4b3c2c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a8f2bde1c0b1c6895d945b9ce4b3c2c5f">ModuleSpanningTree::OnDelLine</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever an xline is deleted MANUALLY. This method is triggered after the line is deleted. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user removing the line or NULL for local server </td></tr>
    <tr><td class="paramname">line</td><td>the line being deleted </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#aa784e9b35582872ca8228053c93615d7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a04cdfa23fcbbd8300eb8c76bad5087e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a04cdfa23fcbbd8300eb8c76bad5087e6">ModuleSpanningTree::OnGetServerDescription</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>servername</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows modules to alter or create server descriptions Whenever a module requires a server description, for example for display in WHOIS, this function is called in all modules. You may change or define the description given in std::string &amp;description. If you do, this description will be shown in the WHOIS fields. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">servername</td><td>The servername being searched for </td></tr>
    <tr><td class="paramname">description</td><td>Alterable server description for this server </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ad73942a4fa3c80fcee0fbbe501aeae20">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a531e6972fae55a007174f6ede3203521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a531e6972fae55a007174f6ede3203521">ModuleSpanningTree::OnLoadModule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a module is loaded. mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded "m_killwidgets.so" with "m_makewidgets.so". It is highly recommended that modules do <em>NOT</em> bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely neccessary (e.g. a module that extends the features of another module). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>A pointer to the new module </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#abedc27f4e91f68ee71ca14afa91e7145">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a1a293c7afc04ffadebfb1647210a4d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a1a293c7afc04ffadebfb1647210a4d38">ModuleSpanningTree::OnOper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a user opers locally. The <a class="el" href="class_user.html">User</a> will contain the oper mode 'o' as this function is called after any modifications are made to the user's structure by the core. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is opering up </td></tr>
    <tr><td class="paramname">opertype</td><td>The opers type name </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#afb6f7ea0790f23d6c15ff3daf40b7f48">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a76c097965b919eb655c10d00f3d3860a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a76c097965b919eb655c10d00f3d3860a">ModuleSpanningTree::OnPostCommand</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmdResult&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after any command has been executed. This event occurs for all registered commands, wether they are registered in the core, or another module, but it will not occur for invalid commands (e.g. ones which do not exist within the command table). The result code returned by the command handler is provided. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command being executed </td></tr>
    <tr><td class="paramname">parameters</td><td>An array of array of characters containing the parameters for the command </td></tr>
    <tr><td class="paramname">pcnt</td><td>The nuimber of parameters passed to the command </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the command </td></tr>
    <tr><td class="paramname">result</td><td>The return code given by the command handler, one of CMD_SUCCESS or CMD_FAILURE </td></tr>
    <tr><td class="paramname">original_line</td><td>The entire original line as passed to the parser from the user </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a098c9e5b967414eb73f5f1c3eb4952e6">Module</a>.</p>

</div>
</div>
<a class="anchor" id="aeaad217ca3f56a7019bf6d4e30d9a7f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#aeaad217ca3f56a7019bf6d4e30d9a7f6">ModuleSpanningTree::OnPostTopicChange</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a topic has been changed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing the topic </td></tr>
    <tr><td class="paramname">chan</td><td>The channels who's topic is being changed </td></tr>
    <tr><td class="paramname">topic</td><td>The actual topic text </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a9a6faca7798ee9ac8a9330c79bacbcd4">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a186d18c39ac2a022a79f7833150ea150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> <a class="el" href="class_module_spanning_tree.html#a186d18c39ac2a022a79f7833150ea150">ModuleSpanningTree::OnPreCommand</a> </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>*** MODULE EVENTS *** </p>

<p>Reimplemented from <a class="el" href="class_module.html#a678967e0e769ecd295a3a272fa488af3">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ad4f8459faea3633f5f02d38b5945095e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#ad4f8459faea3633f5f02d38b5945095e">ModuleSpanningTree::OnRemoteKill</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>operreason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when an oper wants to disconnect a remote user via KILL </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user sending the KILL </td></tr>
    <tr><td class="paramname">dest</td><td>The user being killed </td></tr>
    <tr><td class="paramname">reason</td><td>The kill reason </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ac7d0823f952be21553f6846617907a36">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ada33998b7616a2c5f4d99fac47302c17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> <a class="el" href="class_module_spanning_tree.html#ada33998b7616a2c5f4d99fac47302c17">ModuleSpanningTree::OnSetAway</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>awaymsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a user sets away or returns from being away. The away message is available as a parameter, but should not be modified. At this stage, it has already been copied into the user record. If awaymsg is empty, the user is returning from away. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user setting away </td></tr>
    <tr><td class="paramname">awaymsg</td><td>The away message of the user, or empty if returning from away </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>nonzero if the away message should be blocked - should ONLY be nonzero for LOCAL users (IS_LOCAL) (no output is returned by core) </dd></dl>

<p>Reimplemented from <a class="el" href="class_module.html#ab16f4b39fb1f4353ad2f5d8b652e7425">Module</a>.</p>

</div>
</div>
<a class="anchor" id="aa853f28ec65cce1f74f69c68fa4596ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> <a class="el" href="class_module_spanning_tree.html#aa853f28ec65cce1f74f69c68fa4596ff">ModuleSpanningTree::OnStats</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_list &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called on all /STATS commands This method is triggered for all /STATS use, including stats symbols handled by the core. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the symbol provided to /STATS </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the /STATS command </td></tr>
    <tr><td class="paramname">results</td><td>A string_list to append results into. You should put all your results into this string_list, rather than displaying them directly, so that your handler will work when remote STATS queries are received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>1 to block the /STATS from being processed by the core, 0 to allow it </dd></dl>

<p>Reimplemented from <a class="el" href="class_module.html#a6fdbb320fa09ddfc3e17249cf0f057ec">Module</a>.</p>

</div>
</div>
<a class="anchor" id="add64ad65a88310e30a23eac209cf7444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#add64ad65a88310e30a23eac209cf7444">ModuleSpanningTree::OnUnloadModule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a module is unloaded. mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded "m_killwidgets.so" with "m_makewidgets.so". It is highly recommended that modules do <em>NOT</em> bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely neccessary (e.g. a module that extends the features of another module). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Pointer to the module being unloaded (still valid) </td></tr>
    <tr><td class="paramname">name</td><td>The filename of the module being unloaded </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ab55ed63d022db5f011db3d8c03ef6953">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a264f10a18eb1c06f8fda1e417d28a02b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a264f10a18eb1c06f8fda1e417d28a02b">ModuleSpanningTree::OnUserConnect</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when a user connects. The details of the connecting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is connecting </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a3910edd1a48dfe4db141b04157627a8e">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ac55ca4b72d767729350834874535bd0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#ac55ca4b72d767729350834874535bd0b">ModuleSpanningTree::OnUserInvite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after a user has been successfully invited to a channel. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user who is issuing the INVITE </td></tr>
    <tr><td class="paramname">dest</td><td>The user being invited </td></tr>
    <tr><td class="paramname">channel</td><td>The channel the user is being invited to </td></tr>
    <tr><td class="paramname">timeout</td><td>The time the invite will expire (0 == never) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ab317fe70e3a528ad41c43f5cb3e252a7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a6b3c027470ceb44bfe8920ff8ba75f13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a6b3c027470ceb44bfe8920ff8ba75f13">ModuleSpanningTree::OnUserJoin</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>created</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when a user joins a channel. The details of the joining user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user, and the details of the channel they have joined is available in the variable <a class="el" href="class_channel.html">Channel</a> *channel </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership being created </td></tr>
    <tr><td class="paramname">sync</td><td>This is set to true if the JOIN is the result of a network sync and the remote user is being introduced to a channel due to the network sync. </td></tr>
    <tr><td class="paramname">created</td><td>This is true if the join created the channel </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ae4e65c3401aff9a6c68e2b2f9f2de5dd">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ae17174311377f47da9f4e74ec6d1f70c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#ae17174311377f47da9f4e74ec6d1f70c">ModuleSpanningTree::OnUserKick</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called whenever a user is kicked. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user issuing the kick </td></tr>
    <tr><td class="paramname">user</td><td>The user being kicked </td></tr>
    <tr><td class="paramname">chan</td><td>The channel the user is being kicked from </td></tr>
    <tr><td class="paramname">reason</td><td>The kick reason </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a0a0c7ca18eadf768e69894f2995b0db7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="aa5f1a1093fda34e0e777a4a4d64bf78b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#aa5f1a1093fda34e0e777a4a4d64bf78b">ModuleSpanningTree::OnUserMessage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after any PRIVMSG sent from a user. The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>the text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. PRIVMSG #chan has status== '@', 0 to send to everyone. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a57c261f2aa608ecdad8ae704734505f7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a7048e3f4fdd4fe06cb6acae812245d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a7048e3f4fdd4fe06cb6acae812245d86">ModuleSpanningTree::OnUserNotice</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after any NOTICE sent from a user. The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>the text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. NOTICE #chan has status== '@', 0 to send to everyone. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a0a7e309f4ac701329acdc0b5600ee678">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a0d13bb14dec8357a2e99e31f0402b9fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#a0d13bb14dec8357a2e99e31f0402b9fd">ModuleSpanningTree::OnUserPart</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>partmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when a user parts a channel. The details of the leaving user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user, and the details of the channel they have left is available in the variable <a class="el" href="class_channel.html">Channel</a> *channel </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership being destroyed </td></tr>
    <tr><td class="paramname">partmessage</td><td>The part message, or an empty string (may be modified) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a100db8d416d1484716999076880f63d5">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ac2e9651f46a462c7c49fe867085219ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#ac2e9651f46a462c7c49fe867085219ea">ModuleSpanningTree::OnUserPostNick</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldnick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after any nickchange, local or remote. This can be used to track users after nickchanges have been applied. Please note that although you can see remote nickchanges through this function, you should NOT make any changes to the <a class="el" href="class_user.html">User</a> if the user is a remote user as this may cause a desnyc. check user-&gt;server before taking any action (including returning nonzero from the method). Because this method is called after the nickchange is taken place, no return values are possible to indicate forbidding of the nick change. Use OnUserPreNick for this. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing their nick </td></tr>
    <tr><td class="paramname">oldnick</td><td>The old nickname of the user before the nickchange </td></tr>
  </table>
  </dd>
</dl>
<p>IMPORTANT: We don't update the TS if the oldnick is just a case change of the newnick!</p>

<p>Reimplemented from <a class="el" href="class_module.html#ad35164fe098f2acdec99d3e242e585e9">Module</a>.</p>

</div>
</div>
<a class="anchor" id="acbafe4fcda429c26bcc54dbea536dad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#acbafe4fcda429c26bcc54dbea536dad4">ModuleSpanningTree::OnUserQuit</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oper_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when a user quits. The details of the exiting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user This event is only called when the user is fully registered when they quit. To catch raw disconnections, use the OnUserDisconnect method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is quitting </td></tr>
    <tr><td class="paramname">message</td><td>The user's quit message (as seen by non-opers) </td></tr>
    <tr><td class="paramname">oper_message</td><td>The user's quit message (as seen by opers) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a467945d27be3edec8fbd0de9a37a0c31">Module</a>.</p>

</div>
</div>
<a class="anchor" id="af8a2bb4fd3cb1b810e56ec06c1865cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#af8a2bb4fd3cb1b810e56ec06c1865cd1">ModuleSpanningTree::OnWallops</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called after every WALLOPS command. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the WALLOPS </td></tr>
    <tr><td class="paramname">text</td><td>The content of the WALLOPS message </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#aa76e89f05626000f80f205db32671d56">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ab48b2a66f23fd6bd87aa1c07ef3d6e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#ab48b2a66f23fd6bd87aa1c07ef3d6e74">ModuleSpanningTree::ReadConfig</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_config_read_status.html">ConfigReadStatus</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configuration reading hook. Called after <a class="el" href="class_module.html#ac48c5a93937838e78b2c2063f24cf2f8">early_init()</a> and before <a class="el" href="class_module_spanning_tree.html#a450402b81db47b1d4bc5cb3a1110b056">init()</a> on module load, and on a rehash. </p>

<p>Reimplemented from <a class="el" href="class_module.html#acdc5c4efa3e84f597404f96a7ecb33a0">Module</a>.</p>

</div>
</div>
<a class="anchor" id="af5a03a072da6682bcee388c0381edcf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#af5a03a072da6682bcee388c0381edcf8">ModuleSpanningTree::ShowLinks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_server.html">TreeServer</a> *&#160;</td>
          <td class="paramname"><em>Current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shows /LINKS </p>

</div>
</div>
<a class="anchor" id="ae251705b9e9f4eae2e7c5cec1be59913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_module_spanning_tree.html#ae251705b9e9f4eae2e7c5cec1be59913">ModuleSpanningTree::ShowMap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_server.html">TreeServer</a> *&#160;</td>
          <td class="paramname"><em>Current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>maxnamew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Show MAP output to a user (recursive) </p>

</div>
</div>
<a class="anchor" id="af46c2f0ec066859a3245610a19ddcb34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_module_spanning_tree.html#af46c2f0ec066859a3245610a19ddcb34">ModuleSpanningTree::TimeToStr</a> </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>secs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Display a time as a human readable string </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3332c431147e5601e1b2634d6785d371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_module_spanning_tree.html#a3332c431147e5601e1b2634d6785d371">ModuleSpanningTree::loopCall</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set to true if inside a spanningtree call, to prevent sending xlines and other things back to their source </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/m_spanningtree/<a class="el" href="main_8h_source.html">main.h</a></li>
<li>src/modules/m_spanningtree/main.cpp</li>
<li>src/modules/m_spanningtree/override_map.cpp</li>
<li>src/modules/m_spanningtree/override_squit.cpp</li>
<li>src/modules/m_spanningtree/override_stats.cpp</li>
<li>src/modules/m_spanningtree/postcommand.cpp</li>
<li>src/modules/m_spanningtree/precommand.cpp</li>
<li>src/modules/m_spanningtree/utils.cpp</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
