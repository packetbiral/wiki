<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InspIRCd: include/modules.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">2.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">include/modules.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*       +------------------------------------+</span>
<a name="l00002"></a>00002 <span class="comment"> *       | Inspire Internet Relay Chat Daemon |</span>
<a name="l00003"></a>00003 <span class="comment"> *       +------------------------------------+</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> *  InspIRCd: (C) 2002-2010 InspIRCd Development Team</span>
<a name="l00006"></a>00006 <span class="comment"> * See: http://wiki.inspircd.org/Credits</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * This program is free but copyrighted software; see</span>
<a name="l00009"></a>00009 <span class="comment"> *          the file COPYING for details.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * ---------------------------------------------------</span>
<a name="l00012"></a>00012 <span class="comment"> */</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#ifndef MODULES_H</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#define MODULES_H</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;dynamic.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;base.h&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;ctables.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;inspsocket.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;deque&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;timer.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;mode.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;dns.h&quot;</span>
<a name="l00027"></a>00027 
<a name="l00030"></a>00030 <span class="keyword">enum</span> ModuleFlags {
<a name="l00031"></a>00031         VF_NONE = 0,            <span class="comment">// module is not special at all</span>
<a name="l00032"></a>00032         VF_STATIC = 1,          <span class="comment">// module is static, cannot be /unloadmodule&#39;d</span>
<a name="l00033"></a>00033         VF_VENDOR = 2,          <span class="comment">// module is a vendor module (came in the original tarball, not 3rd party)</span>
<a name="l00034"></a>00034         VF_COMMON = 4,          <span class="comment">// module needs to be common on all servers in a network to link</span>
<a name="l00035"></a>00035         VF_OPTCOMMON = 8,       <span class="comment">// module should be common on all servers for unsurprising behavior</span>
<a name="l00036"></a>00036         VF_CORE = 16            <span class="comment">// module is a core command, can be assumed loaded on all servers</span>
<a name="l00037"></a>00037 };
<a name="l00038"></a>00038 
<a name="l00041"></a>00041 <span class="keyword">enum</span> TargetTypeFlags {
<a name="l00042"></a>00042         TYPE_USER = 1,
<a name="l00043"></a>00043         TYPE_CHANNEL,
<a name="l00044"></a>00044         TYPE_SERVER,
<a name="l00045"></a>00045         TYPE_OTHER
<a name="l00046"></a>00046 };
<a name="l00047"></a>00047 
<a name="l00050"></a>00050 <span class="keyword">enum</span> MessageType {
<a name="l00051"></a>00051         MSG_PRIVMSG = 0,
<a name="l00052"></a>00052         MSG_NOTICE = 1
<a name="l00053"></a>00053 };
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="preprocessor">#define MOD_RES_ALLOW (ModResult(1))</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#define MOD_RES_PASSTHRU (ModResult(0))</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#define MOD_RES_DENY (ModResult(-1))</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>
<a name="l00063"></a><a class="code" href="struct_mod_result.html">00063</a> <span class="keyword">struct </span><a class="code" href="struct_mod_result.html">ModResult</a> {
<a name="l00064"></a>00064         <span class="keywordtype">int</span> res;
<a name="l00065"></a>00065         <a class="code" href="struct_mod_result.html">ModResult</a>() : res(0) {}
<a name="l00066"></a>00066         <span class="keyword">explicit</span> <a class="code" href="struct_mod_result.html">ModResult</a>(<span class="keywordtype">int</span> r) : res(r) {}
<a name="l00067"></a>00067         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="struct_mod_result.html">ModResult</a>&amp; r)<span class="keyword"> const</span>
<a name="l00068"></a>00068 <span class="keyword">        </span>{
<a name="l00069"></a>00069                 <span class="keywordflow">return</span> res == r.res;
<a name="l00070"></a>00070         }
<a name="l00071"></a>00071         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> <a class="code" href="struct_mod_result.html">ModResult</a>&amp; r)<span class="keyword"> const</span>
<a name="l00072"></a>00072 <span class="keyword">        </span>{
<a name="l00073"></a>00073                 <span class="keywordflow">return</span> res != r.res;
<a name="l00074"></a>00074         }
<a name="l00075"></a>00075         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!()<span class="keyword"> const</span>
<a name="l00076"></a>00076 <span class="keyword">        </span>{
<a name="l00077"></a>00077                 <span class="keywordflow">return</span> !res;
<a name="l00078"></a>00078         }
<a name="l00079"></a>00079         <span class="keyword">inline</span> <span class="keywordtype">bool</span> check(<span class="keywordtype">bool</span> def)<span class="keyword"> const</span>
<a name="l00080"></a>00080 <span class="keyword">        </span>{
<a name="l00081"></a>00081                 <span class="keywordflow">return</span> (res == 1 || (res == 0 &amp;&amp; def));
<a name="l00082"></a>00082         }
<a name="l00086"></a><a class="code" href="struct_mod_result.html#aba09d75e0ab80ad8be8898f2f39a41bb">00086</a>         <span class="keyword">inline</span> <a class="code" href="struct_mod_result.html">ModResult</a> <a class="code" href="struct_mod_result.html#aba09d75e0ab80ad8be8898f2f39a41bb">operator+</a>(<span class="keyword">const</span> <a class="code" href="struct_mod_result.html">ModResult</a>&amp; r)<span class="keyword"> const</span>
<a name="l00087"></a>00087 <span class="keyword">        </span>{
<a name="l00088"></a>00088                 <span class="keywordflow">if</span> (res == r.res || r.res == 0)
<a name="l00089"></a>00089                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00090"></a>00090                 <span class="keywordflow">if</span> (res == 0)
<a name="l00091"></a>00091                         <span class="keywordflow">return</span> r;
<a name="l00092"></a>00092                 <span class="comment">// they are different, and neither is passthru</span>
<a name="l00093"></a>00093                 <span class="keywordflow">return</span> MOD_RES_ALLOW;
<a name="l00094"></a>00094         }
<a name="l00095"></a>00095 };
<a name="l00096"></a>00096 
<a name="l00100"></a>00100 <span class="preprocessor">#define INSPIRCD_VERSION_MAJ 200</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00107"></a>00107 <span class="preprocessor">#define INSPIRCD_VERSION_API 1</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>
<a name="l00114"></a>00114 <span class="preprocessor">#define FOREACH_MOD(y,x) do { \</span>
<a name="l00115"></a>00115 <span class="preprocessor">        EventHandlerIter safei; \</span>
<a name="l00116"></a>00116 <span class="preprocessor">        for (EventHandlerIter _i = ServerInstance-&gt;Modules-&gt;EventHandlers[y].begin(); _i != ServerInstance-&gt;Modules-&gt;EventHandlers[y].end(); ) \</span>
<a name="l00117"></a>00117 <span class="preprocessor">        { \</span>
<a name="l00118"></a>00118 <span class="preprocessor">                safei = _i; \</span>
<a name="l00119"></a>00119 <span class="preprocessor">                ++safei; \</span>
<a name="l00120"></a>00120 <span class="preprocessor">                try \</span>
<a name="l00121"></a>00121 <span class="preprocessor">                { \</span>
<a name="l00122"></a>00122 <span class="preprocessor">                        (*_i)-&gt;x ; \</span>
<a name="l00123"></a>00123 <span class="preprocessor">                } \</span>
<a name="l00124"></a>00124 <span class="preprocessor">                catch (CoreException&amp; modexcept) \</span>
<a name="l00125"></a>00125 <span class="preprocessor">                { \</span>
<a name="l00126"></a>00126 <span class="preprocessor">                        ServerInstance-&gt;Logs-&gt;Log(&quot;MODULE&quot;,DEFAULT,&quot;Exception caught: %s&quot;,modexcept.GetReason()); \</span>
<a name="l00127"></a>00127 <span class="preprocessor">                } \</span>
<a name="l00128"></a>00128 <span class="preprocessor">                _i = safei; \</span>
<a name="l00129"></a>00129 <span class="preprocessor">        } \</span>
<a name="l00130"></a>00130 <span class="preprocessor">} while (0);</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>
<a name="l00138"></a>00138 <span class="preprocessor">#define DO_EACH_HOOK(n,v,args) \</span>
<a name="l00139"></a>00139 <span class="preprocessor">do { \</span>
<a name="l00140"></a>00140 <span class="preprocessor">        EventHandlerIter iter_ ## n = ServerInstance-&gt;Modules-&gt;EventHandlers[I_ ## n].begin(); \</span>
<a name="l00141"></a>00141 <span class="preprocessor">        while (iter_ ## n != ServerInstance-&gt;Modules-&gt;EventHandlers[I_ ## n].end()) \</span>
<a name="l00142"></a>00142 <span class="preprocessor">        { \</span>
<a name="l00143"></a>00143 <span class="preprocessor">                Module* mod_ ## n = *iter_ ## n; \</span>
<a name="l00144"></a>00144 <span class="preprocessor">                iter_ ## n ++; \</span>
<a name="l00145"></a>00145 <span class="preprocessor">                try \</span>
<a name="l00146"></a>00146 <span class="preprocessor">                { \</span>
<a name="l00147"></a>00147 <span class="preprocessor">                        v = (mod_ ## n)-&gt;n args;</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>
<a name="l00149"></a>00149 <span class="preprocessor">#define WHILE_EACH_HOOK(n) \</span>
<a name="l00150"></a>00150 <span class="preprocessor">                } \</span>
<a name="l00151"></a>00151 <span class="preprocessor">                catch (CoreException&amp; except_ ## n) \</span>
<a name="l00152"></a>00152 <span class="preprocessor">                { \</span>
<a name="l00153"></a>00153 <span class="preprocessor">                        ServerInstance-&gt;Logs-&gt;Log(&quot;MODULE&quot;,DEFAULT,&quot;Exception caught: %s&quot;, (except_ ## n).GetReason()); \</span>
<a name="l00154"></a>00154 <span class="preprocessor">                        (void) mod_ ## n; </span><span class="comment">/* catch mismatched pairs */</span> \
<a name="l00155"></a>00155                 } \
<a name="l00156"></a>00156         } \
<a name="l00157"></a>00157 } while(0)
<a name="l00158"></a>00158 
<a name="l00166"></a>00166 <span class="preprocessor">#define FIRST_MOD_RESULT(n,v,args) do { \</span>
<a name="l00167"></a>00167 <span class="preprocessor">        v = MOD_RES_PASSTHRU; \</span>
<a name="l00168"></a>00168 <span class="preprocessor">        DO_EACH_HOOK(n,v,args) \</span>
<a name="l00169"></a>00169 <span class="preprocessor">        { \</span>
<a name="l00170"></a>00170 <span class="preprocessor">                if (v != MOD_RES_PASSTHRU) \</span>
<a name="l00171"></a>00171 <span class="preprocessor">                        break; \</span>
<a name="l00172"></a>00172 <span class="preprocessor">        } \</span>
<a name="l00173"></a>00173 <span class="preprocessor">        WHILE_EACH_HOOK(n); \</span>
<a name="l00174"></a>00174 <span class="preprocessor">} while (0)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>
<a name="l00180"></a><a class="code" href="class_version.html">00180</a> <span class="keyword">class </span>CoreExport <a class="code" href="class_version.html">Version</a>
<a name="l00181"></a>00181 {
<a name="l00182"></a>00182  <span class="keyword">public</span>:
<a name="l00185"></a><a class="code" href="class_version.html#a9344d3cd11423957b9ecd193f851f8a3">00185</a>         <span class="keyword">const</span> std::string <a class="code" href="class_version.html#a9344d3cd11423957b9ecd193f851f8a3">description</a>;
<a name="l00186"></a>00186 
<a name="l00189"></a><a class="code" href="class_version.html#a9bf5196fb39e8d0864ae0015c207ee4f">00189</a>         <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="class_version.html#a9bf5196fb39e8d0864ae0015c207ee4f">Flags</a>;
<a name="l00190"></a>00190 
<a name="l00192"></a><a class="code" href="class_version.html#a582d176eac036b28cdd462c3cb6af917">00192</a>         <span class="keyword">const</span> std::string <a class="code" href="class_version.html#a582d176eac036b28cdd462c3cb6af917">link_data</a>;
<a name="l00193"></a>00193 
<a name="l00195"></a>00195         <a class="code" href="class_version.html">Version</a>(<span class="keyword">const</span> std::string &amp;desc, <span class="keywordtype">int</span> flags = VF_NONE);
<a name="l00196"></a>00196 
<a name="l00198"></a>00198         <a class="code" href="class_version.html">Version</a>(<span class="keyword">const</span> std::string &amp;desc, <span class="keywordtype">int</span> flags, <span class="keyword">const</span> std::string&amp; linkdata);
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="keyword">virtual</span> ~<a class="code" href="class_version.html">Version</a>() {}
<a name="l00201"></a>00201 };
<a name="l00202"></a>00202 
<a name="l00208"></a><a class="code" href="class_request.html">00208</a> <span class="keyword">class </span>CoreExport <a class="code" href="class_request.html">Request</a> : <span class="keyword">public</span> <a class="code" href="classclassbase.html">classbase</a>
<a name="l00209"></a>00209 {
<a name="l00210"></a>00210  <span class="keyword">public</span>:
<a name="l00215"></a><a class="code" href="class_request.html#aee070353bc753ed93af08b35d02d3662">00215</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> <a class="code" href="class_request.html#aee070353bc753ed93af08b35d02d3662">id</a>;
<a name="l00219"></a><a class="code" href="class_request.html#a1b27232017519f5fd54cf1857b6e10ca">00219</a>         <a class="code" href="classreference.html">ModuleRef</a> <a class="code" href="class_request.html#a1b27232017519f5fd54cf1857b6e10ca">source</a>;
<a name="l00222"></a><a class="code" href="class_request.html#a734057f94a3f7627d1a92bf23a3e0f55">00222</a>         <a class="code" href="classreference.html">ModuleRef</a> <a class="code" href="class_request.html#a734057f94a3f7627d1a92bf23a3e0f55">dest</a>;
<a name="l00223"></a>00223 
<a name="l00231"></a>00231         <a class="code" href="class_request.html">Request</a>(<a class="code" href="class_module.html">Module</a>* src, <a class="code" href="class_module.html">Module</a>* dst, <span class="keyword">const</span> <span class="keywordtype">char</span>* idstr);
<a name="l00234"></a>00234         <span class="keywordtype">void</span> Send();
<a name="l00235"></a>00235 };
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 
<a name="l00243"></a><a class="code" href="class_event.html">00243</a> <span class="keyword">class </span>CoreExport <a class="code" href="class_event.html">Event</a> : <span class="keyword">public</span> <a class="code" href="classclassbase.html">classbase</a>
<a name="l00244"></a>00244 {
<a name="l00245"></a>00245  <span class="keyword">public</span>:
<a name="l00249"></a><a class="code" href="class_event.html#a5b0ea6da61961b9e34a667c569d2ab3e">00249</a>         <a class="code" href="classreference.html">ModuleRef</a> <a class="code" href="class_event.html#a5b0ea6da61961b9e34a667c569d2ab3e">source</a>;
<a name="l00254"></a><a class="code" href="class_event.html#a8566f6b1af844306a135e4bc2d2cad62">00254</a>         <span class="keyword">const</span> std::string <a class="code" href="class_event.html#a8566f6b1af844306a135e4bc2d2cad62">id</a>;
<a name="l00255"></a>00255 
<a name="l00258"></a>00258         <a class="code" href="class_event.html">Event</a>(<a class="code" href="class_module.html">Module</a>* src, <span class="keyword">const</span> std::string &amp;eventid);
<a name="l00263"></a>00263         <span class="keywordtype">void</span> Send();
<a name="l00264"></a>00264 };
<a name="l00265"></a>00265 
<a name="l00266"></a><a class="code" href="class_data_provider.html">00266</a> <span class="keyword">class </span>CoreExport <a class="code" href="class_data_provider.html">DataProvider</a> : <span class="keyword">public</span> <a class="code" href="class_service_provider.html">ServiceProvider</a>
<a name="l00267"></a>00267 {
<a name="l00268"></a>00268  <span class="keyword">public</span>:
<a name="l00269"></a>00269         <a class="code" href="class_data_provider.html">DataProvider</a>(<a class="code" href="class_module.html">Module</a>* Creator, <span class="keyword">const</span> std::string&amp; Name)
<a name="l00270"></a>00270                 : <a class="code" href="class_service_provider.html">ServiceProvider</a>(Creator, Name, SERVICE_DATA) {}
<a name="l00271"></a>00271 };
<a name="l00272"></a>00272 
<a name="l00273"></a><a class="code" href="classdynamic__reference__base.html">00273</a> <span class="keyword">class </span>CoreExport <a class="code" href="classdynamic__reference__base.html">dynamic_reference_base</a> : <span class="keyword">public</span> <a class="code" href="classinterfacebase.html">interfacebase</a>
<a name="l00274"></a>00274 {
<a name="l00275"></a>00275  <span class="keyword">private</span>:
<a name="l00276"></a>00276         std::string name;
<a name="l00277"></a>00277  <span class="keyword">protected</span>:
<a name="l00278"></a>00278         <a class="code" href="class_data_provider.html">DataProvider</a>* value;
<a name="l00279"></a>00279  <span class="keyword">public</span>:
<a name="l00280"></a>00280         <a class="code" href="classreference.html">ModuleRef</a> creator;
<a name="l00281"></a>00281         <a class="code" href="classdynamic__reference__base.html">dynamic_reference_base</a>(<a class="code" href="class_module.html">Module</a>* Creator, <span class="keyword">const</span> std::string&amp; Name);
<a name="l00282"></a>00282         ~<a class="code" href="classdynamic__reference__base.html">dynamic_reference_base</a>();
<a name="l00283"></a>00283         <span class="keyword">inline</span> <span class="keywordtype">void</span> ClearCache() { value = NULL; }
<a name="l00284"></a>00284         <span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; GetProvider() { <span class="keywordflow">return</span> name; }
<a name="l00285"></a>00285         <span class="keywordtype">void</span> SetProvider(<span class="keyword">const</span> std::string&amp; newname);
<a name="l00286"></a>00286         <span class="keywordtype">void</span> lookup();
<a name="l00287"></a>00287         operator bool();
<a name="l00288"></a>00288         <span class="keyword">static</span> <span class="keywordtype">void</span> reset_all();
<a name="l00289"></a>00289 };
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00292"></a><a class="code" href="classdynamic__reference.html">00292</a> <span class="keyword">class </span><a class="code" href="classdynamic__reference.html">dynamic_reference</a> : <span class="keyword">public</span> <a class="code" href="classdynamic__reference__base.html">dynamic_reference_base</a>
<a name="l00293"></a>00293 {
<a name="l00294"></a>00294  <span class="keyword">public</span>:
<a name="l00295"></a>00295         <a class="code" href="classdynamic__reference.html">dynamic_reference</a>(<a class="code" href="class_module.html">Module</a>* Creator, <span class="keyword">const</span> std::string&amp; Name)
<a name="l00296"></a>00296                 : <a class="code" href="classdynamic__reference__base.html">dynamic_reference_base</a>(Creator, Name) {}
<a name="l00297"></a>00297         <span class="keyword">inline</span> T* operator-&gt;()
<a name="l00298"></a>00298         {
<a name="l00299"></a>00299                 <span class="keywordflow">if</span> (!value)
<a name="l00300"></a>00300                         lookup();
<a name="l00301"></a>00301                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(value);
<a name="l00302"></a>00302         }
<a name="l00303"></a>00303 };
<a name="l00304"></a>00304 
<a name="l00307"></a>00307 <span class="keyword">enum</span> Priority { PRIORITY_FIRST, PRIORITY_LAST, PRIORITY_BEFORE, PRIORITY_AFTER };
<a name="l00308"></a>00308 
<a name="l00311"></a>00311 <span class="keyword">enum</span> Implementation
<a name="l00312"></a>00312 {
<a name="l00313"></a>00313         I_BEGIN,
<a name="l00314"></a>00314         I_OnUserConnect, I_OnUserQuit, I_OnUserDisconnect, I_OnUserJoin, I_OnUserPart, I_OnRehash,
<a name="l00315"></a>00315         I_OnSendSnotice, I_OnUserPreJoin, I_OnUserPreKick, I_OnUserKick, I_OnOper, I_OnInfo, I_OnWhois,
<a name="l00316"></a>00316         I_OnUserPreInvite, I_OnUserInvite, I_OnUserPreMessage, I_OnUserPreNotice, I_OnUserPreNick,
<a name="l00317"></a>00317         I_OnUserMessage, I_OnUserNotice, I_OnMode, I_OnGetServerDescription, I_OnSyncUser,
<a name="l00318"></a>00318         I_OnSyncChannel, I_OnDecodeMetaData, I_OnWallops, I_OnAcceptConnection, I_OnUserInit,
<a name="l00319"></a>00319         I_OnChangeHost, I_OnChangeName, I_OnAddLine, I_OnDelLine, I_OnExpireLine,
<a name="l00320"></a>00320         I_OnUserPostNick, I_OnPreMode, I_On005Numeric, I_OnKill, I_OnRemoteKill, I_OnLoadModule,
<a name="l00321"></a>00321         I_OnUnloadModule, I_OnBackgroundTimer, I_OnPreCommand, I_OnCheckReady, I_OnCheckInvite,
<a name="l00322"></a>00322         I_OnRawMode, I_OnCheckKey, I_OnCheckLimit, I_OnCheckBan, I_OnCheckChannelBan, I_OnExtBanCheck,
<a name="l00323"></a>00323         I_OnStats, I_OnChangeLocalUserHost, I_OnPreTopicChange,
<a name="l00324"></a>00324         I_OnPostTopicChange, I_OnEvent, I_OnGlobalOper, I_OnPostConnect, I_OnAddBan,
<a name="l00325"></a>00325         I_OnDelBan, I_OnChangeLocalUserGECOS, I_OnUserRegister, I_OnChannelPreDelete, I_OnChannelDelete,
<a name="l00326"></a>00326         I_OnPostOper, I_OnSyncNetwork, I_OnSetAway, I_OnPostCommand, I_OnPostJoin,
<a name="l00327"></a>00327         I_OnWhoisLine, I_OnBuildNeighborList, I_OnGarbageCollect, I_OnSetConnectClass,
<a name="l00328"></a>00328         I_OnText, I_OnPassCompare, I_OnRunTestSuite, I_OnNamesListItem, I_OnNumeric, I_OnHookIO,
<a name="l00329"></a>00329         I_OnPreRehash, I_OnModuleRehash, I_OnSendWhoLine, I_OnChangeIdent,
<a name="l00330"></a>00330         I_END
<a name="l00331"></a>00331 };
<a name="l00332"></a>00332 
<a name="l00338"></a><a class="code" href="class_module.html">00338</a> <span class="keyword">class </span>CoreExport <a class="code" href="class_module.html">Module</a> : <span class="keyword">public</span> <a class="code" href="classclassbase.html">classbase</a>, <span class="keyword">public</span> <a class="code" href="classusecountbase.html">usecountbase</a>
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340  <span class="keyword">public</span>:
<a name="l00343"></a><a class="code" href="class_module.html#a4b9d41041b7b56a786064020e9c50c75">00343</a>         std::string <a class="code" href="class_module.html#a4b9d41041b7b56a786064020e9c50c75">ModuleSourceFile</a>;
<a name="l00346"></a><a class="code" href="class_module.html#a5bbdc3c59248520549e5904bb402e2cb">00346</a>         <a class="code" href="class_d_l_l_manager.html">DLLManager</a>* <a class="code" href="class_module.html#a5bbdc3c59248520549e5904bb402e2cb">ModuleDLLManager</a>;
<a name="l00347"></a>00347 
<a name="l00352"></a>00352         <a class="code" href="class_module.html">Module</a>();
<a name="l00353"></a>00353 
<a name="l00357"></a><a class="code" href="class_module.html#ab19e59816d97db07363143c859ad0c10">00357</a>         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_module.html#ab19e59816d97db07363143c859ad0c10">init</a>() {}
<a name="l00358"></a>00358 
<a name="l00362"></a>00362         <span class="keyword">virtual</span> <a class="code" href="class_cull_result.html">CullResult</a> <a class="code" href="classclassbase.html#a2a773ec2f42d047e0ce250553f44d831">cull</a>();
<a name="l00363"></a>00363 
<a name="l00367"></a>00367         <span class="keyword">virtual</span> ~<a class="code" href="class_module.html">Module</a>();
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Prioritize()
<a name="l00370"></a>00370         {
<a name="l00371"></a>00371         }
<a name="l00372"></a>00372 
<a name="l00377"></a>00377         <span class="keyword">virtual</span> <a class="code" href="class_version.html">Version</a> GetVersion() = 0;
<a name="l00378"></a>00378 
<a name="l00383"></a>00383         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserConnect(<a class="code" href="class_local_user.html">LocalUser</a>* user);
<a name="l00384"></a>00384 
<a name="l00393"></a>00393         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserQuit(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;message, <span class="keyword">const</span> std::string &amp;oper_message);
<a name="l00394"></a>00394 
<a name="l00401"></a>00401         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserDisconnect(<a class="code" href="class_local_user.html">LocalUser</a>* user);
<a name="l00402"></a>00402 
<a name="l00407"></a>00407         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnChannelPreDelete(<a class="code" href="class_channel.html">Channel</a> *chan);
<a name="l00408"></a>00408 
<a name="l00412"></a>00412         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnChannelDelete(<a class="code" href="class_channel.html">Channel</a>* chan);
<a name="l00413"></a>00413 
<a name="l00422"></a>00422         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserJoin(<a class="code" href="class_membership.html">Membership</a>* memb, <span class="keywordtype">bool</span> sync, <span class="keywordtype">bool</span> created, CUList&amp; except_list);
<a name="l00423"></a>00423 
<a name="l00429"></a>00429         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnPostJoin(<a class="code" href="class_membership.html">Membership</a>*);
<a name="l00430"></a>00430 
<a name="l00437"></a>00437         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserPart(<a class="code" href="class_membership.html">Membership</a>* memb, std::string &amp;partmessage, CUList&amp; except_list);
<a name="l00438"></a>00438 
<a name="l00449"></a>00449         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnPreRehash(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;parameter);
<a name="l00450"></a>00450 
<a name="l00459"></a>00459         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnModuleRehash(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;parameter);
<a name="l00460"></a>00460 
<a name="l00467"></a>00467         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnRehash(<a class="code" href="class_user.html">User</a>* user);
<a name="l00468"></a>00468 
<a name="l00476"></a>00476         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnSendSnotice(<span class="keywordtype">char</span> &amp;snomask, std::string &amp;type, <span class="keyword">const</span> std::string &amp;message);
<a name="l00477"></a>00477 
<a name="l00498"></a>00498         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnUserPreJoin(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan, <span class="keyword">const</span> <span class="keywordtype">char</span>* cname, std::string &amp;privs, <span class="keyword">const</span> std::string &amp;keygiven);
<a name="l00499"></a>00499 
<a name="l00510"></a>00510         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnUserPreKick(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_membership.html">Membership</a>* memb, <span class="keyword">const</span> std::string &amp;reason);
<a name="l00511"></a>00511 
<a name="l00520"></a>00520         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserKick(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_membership.html">Membership</a>* memb, <span class="keyword">const</span> std::string &amp;reason, CUList&amp; except_list);
<a name="l00521"></a>00521 
<a name="l00528"></a>00528         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnOper(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;opertype);
<a name="l00529"></a>00529 
<a name="l00538"></a>00538         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnPostOper(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;opername, <span class="keyword">const</span> std::string &amp;opertype);
<a name="l00539"></a>00539 
<a name="l00550"></a>00550         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnInfo(<a class="code" href="class_user.html">User</a>* user);
<a name="l00551"></a>00551 
<a name="l00558"></a>00558         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnWhois(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_user.html">User</a>* dest);
<a name="l00559"></a>00559 
<a name="l00570"></a>00570         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnUserPreInvite(<a class="code" href="class_user.html">User</a>* source,<a class="code" href="class_user.html">User</a>* dest,<a class="code" href="class_channel.html">Channel</a>* channel, time_t timeout);
<a name="l00571"></a>00571 
<a name="l00580"></a>00580         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserInvite(<a class="code" href="class_user.html">User</a>* source,<a class="code" href="class_user.html">User</a>* dest,<a class="code" href="class_channel.html">Channel</a>* channel, time_t timeout);
<a name="l00581"></a>00581 
<a name="l00598"></a>00598         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnUserPreMessage(<a class="code" href="class_user.html">User</a>* user,<span class="keywordtype">void</span>* dest,<span class="keywordtype">int</span> target_type, std::string &amp;text,<span class="keywordtype">char</span> status, CUList &amp;exempt_list);
<a name="l00599"></a>00599 
<a name="l00619"></a>00619         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnUserPreNotice(<a class="code" href="class_user.html">User</a>* user,<span class="keywordtype">void</span>* dest,<span class="keywordtype">int</span> target_type, std::string &amp;text,<span class="keywordtype">char</span> status, CUList &amp;exempt_list);
<a name="l00620"></a>00620 
<a name="l00630"></a>00630         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnBuildNeighborList(<a class="code" href="class_user.html">User</a>* source, UserChanList &amp;include_c, std::map&lt;User*,bool&gt; &amp;exceptions);
<a name="l00631"></a>00631 
<a name="l00642"></a>00642         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnUserPreNick(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;newnick);
<a name="l00643"></a>00643 
<a name="l00653"></a>00653         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserMessage(<a class="code" href="class_user.html">User</a>* user, <span class="keywordtype">void</span>* dest, <span class="keywordtype">int</span> target_type, <span class="keyword">const</span> std::string &amp;text, <span class="keywordtype">char</span> status, <span class="keyword">const</span> CUList &amp;exempt_list);
<a name="l00654"></a>00654 
<a name="l00664"></a>00664         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserNotice(<a class="code" href="class_user.html">User</a>* user, <span class="keywordtype">void</span>* dest, <span class="keywordtype">int</span> target_type, <span class="keyword">const</span> std::string &amp;text, <span class="keywordtype">char</span> status, <span class="keyword">const</span> CUList &amp;exempt_list);
<a name="l00665"></a>00665 
<a name="l00678"></a>00678         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnText(<a class="code" href="class_user.html">User</a>* user, <span class="keywordtype">void</span>* dest, <span class="keywordtype">int</span> target_type, <span class="keyword">const</span> std::string &amp;text, <span class="keywordtype">char</span> status, CUList &amp;exempt_list);
<a name="l00679"></a>00679 
<a name="l00690"></a>00690         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnMode(<a class="code" href="class_user.html">User</a>* user, <span class="keywordtype">void</span>* dest, <span class="keywordtype">int</span> target_type, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;text, <span class="keyword">const</span> std::vector&lt;TranslateType&gt; &amp;translate);
<a name="l00691"></a>00691 
<a name="l00700"></a>00700         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnGetServerDescription(<span class="keyword">const</span> std::string &amp;servername,std::string &amp;description);
<a name="l00701"></a>00701 
<a name="l00714"></a>00714         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnSyncUser(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_module.html">Module</a>* proto, <span class="keywordtype">void</span>* opaque);
<a name="l00715"></a>00715 
<a name="l00729"></a>00729         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnSyncChannel(<a class="code" href="class_channel.html">Channel</a>* chan, <a class="code" href="class_module.html">Module</a>* proto, <span class="keywordtype">void</span>* opaque);
<a name="l00730"></a>00730 
<a name="l00731"></a>00731         <span class="comment">/* Allows modules to syncronize metadata not related to users or channels, over the network during a netburst.</span>
<a name="l00732"></a>00732 <span class="comment">         * Whenever the linking module wants to send out data, but doesnt know what the data</span>
<a name="l00733"></a>00733 <span class="comment">         * represents (e.g. it is Extensible metadata, added to a User or Channel by a module) then</span>
<a name="l00734"></a>00734 <span class="comment">         * this method is called. You should use the ProtoSendMetaData function after you&#39;ve</span>
<a name="l00735"></a>00735 <span class="comment">         * correctly decided how the data should be represented, to send the metadata on its way if</span>
<a name="l00736"></a>00736 <span class="comment">         * if it belongs to your module.</span>
<a name="l00737"></a>00737 <span class="comment">         * @param proto A pointer to the module handling network protocol</span>
<a name="l00738"></a>00738 <span class="comment">         * @param opaque An opaque pointer set by the protocol module, should not be modified!</span>
<a name="l00739"></a>00739 <span class="comment">         * @param displayable If this value is true, the data is going to be displayed to a user,</span>
<a name="l00740"></a>00740 <span class="comment">         * and not sent across the network. Use this to determine wether or not to show sensitive data.</span>
<a name="l00741"></a>00741 <span class="comment">         */</span>
<a name="l00742"></a>00742         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnSyncNetwork(<a class="code" href="class_module.html">Module</a>* proto, <span class="keywordtype">void</span>* opaque);
<a name="l00743"></a>00743 
<a name="l00751"></a>00751         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnDecodeMetaData(<a class="code" href="class_extensible.html">Extensible</a>* target, <span class="keyword">const</span> std::string &amp;extname, <span class="keyword">const</span> std::string &amp;extdata);
<a name="l00752"></a>00752 
<a name="l00767"></a>00767         <span class="keyword">virtual</span> <span class="keywordtype">void</span> ProtoSendMode(<span class="keywordtype">void</span>* opaque, TargetTypeFlags target_type, <span class="keywordtype">void</span>* target, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;modeline, <span class="keyword">const</span> std::vector&lt;TranslateType&gt; &amp;translate);
<a name="l00768"></a>00768 
<a name="l00783"></a>00783         <span class="keyword">virtual</span> <span class="keywordtype">void</span> ProtoSendMetaData(<span class="keywordtype">void</span>* opaque, <a class="code" href="class_extensible.html">Extensible</a>* target, <span class="keyword">const</span> std::string &amp;extname, <span class="keyword">const</span> std::string &amp;extdata);
<a name="l00784"></a>00784 
<a name="l00789"></a>00789         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnWallops(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;text);
<a name="l00790"></a>00790 
<a name="l00796"></a>00796         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnChangeHost(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;newhost);
<a name="l00797"></a>00797 
<a name="l00803"></a>00803         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnChangeName(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;gecos);
<a name="l00804"></a>00804 
<a name="l00810"></a>00810         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnChangeIdent(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;ident);
<a name="l00811"></a>00811 
<a name="l00817"></a>00817         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnAddLine(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_x_line.html">XLine</a>* line);
<a name="l00818"></a>00818 
<a name="l00824"></a>00824         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnDelLine(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_x_line.html">XLine</a>* line);
<a name="l00825"></a>00825 
<a name="l00830"></a>00830         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnExpireLine(<a class="code" href="class_x_line.html">XLine</a> *line);
<a name="l00831"></a>00831 
<a name="l00841"></a>00841         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnCleanup(<span class="keywordtype">int</span> target_type, <span class="keywordtype">void</span>* item);
<a name="l00842"></a>00842 
<a name="l00852"></a>00852         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserPostNick(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;oldnick);
<a name="l00853"></a>00853 
<a name="l00865"></a>00865         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnPreMode(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_user.html">User</a>* dest, <a class="code" href="class_channel.html">Channel</a>* channel, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; parameters);
<a name="l00866"></a>00866 
<a name="l00871"></a>00871         <span class="keyword">virtual</span> <span class="keywordtype">void</span> On005Numeric(std::string &amp;output);
<a name="l00872"></a>00872 
<a name="l00886"></a>00886         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnKill(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_user.html">User</a>* dest, <span class="keyword">const</span> std::string &amp;reason);
<a name="l00887"></a>00887 
<a name="l00893"></a>00893         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnRemoteKill(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_user.html">User</a>* dest, <span class="keyword">const</span> std::string &amp;reason, <span class="keyword">const</span> std::string &amp;operreason);
<a name="l00894"></a>00894 
<a name="l00906"></a>00906         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnLoadModule(<a class="code" href="class_module.html">Module</a>* mod);
<a name="l00907"></a>00907 
<a name="l00920"></a>00920         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUnloadModule(<a class="code" href="class_module.html">Module</a>* mod);
<a name="l00921"></a>00921 
<a name="l00928"></a>00928         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnBackgroundTimer(time_t curtime);
<a name="l00929"></a>00929 
<a name="l00948"></a>00948         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnPreCommand(std::string &amp;command, std::vector&lt;std::string&gt;&amp; parameters, <a class="code" href="class_local_user.html">LocalUser</a> *user, <span class="keywordtype">bool</span> validated, <span class="keyword">const</span> std::string &amp;original_line);
<a name="l00949"></a>00949 
<a name="l00962"></a>00962         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnPostCommand(<span class="keyword">const</span> std::string &amp;command, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; parameters, <a class="code" href="class_local_user.html">LocalUser</a> *user, CmdResult result, <span class="keyword">const</span> std::string &amp;original_line);
<a name="l00963"></a>00963 
<a name="l00967"></a>00967         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnUserInit(<a class="code" href="class_local_user.html">LocalUser</a>* user);
<a name="l00968"></a>00968 
<a name="l00979"></a>00979         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnCheckReady(<a class="code" href="class_local_user.html">LocalUser</a>* user);
<a name="l00980"></a>00980 
<a name="l00990"></a>00990         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnUserRegister(<a class="code" href="class_local_user.html">LocalUser</a>* user);
<a name="l00991"></a>00991 
<a name="l01000"></a>01000         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnCheckInvite(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan);
<a name="l01001"></a>01001 
<a name="l01014"></a>01014         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnRawMode(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan, <span class="keyword">const</span> <span class="keywordtype">char</span> mode, <span class="keyword">const</span> std::string &amp;param, <span class="keywordtype">bool</span> adding, <span class="keywordtype">int</span> pcnt);
<a name="l01015"></a>01015 
<a name="l01025"></a>01025         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnCheckKey(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan, <span class="keyword">const</span> std::string &amp;keygiven);
<a name="l01026"></a>01026 
<a name="l01035"></a>01035         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnCheckLimit(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan);
<a name="l01036"></a>01036 
<a name="l01044"></a>01044         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnCheckChannelBan(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan);
<a name="l01045"></a>01045 
<a name="l01054"></a>01054         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnCheckBan(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan, <span class="keyword">const</span> std::string&amp; mask);
<a name="l01055"></a>01055 
<a name="l01060"></a>01060         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnExtBanCheck(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan, <span class="keywordtype">char</span> type);
<a name="l01061"></a>01061 
<a name="l01071"></a>01071         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnStats(<span class="keywordtype">char</span> symbol, <a class="code" href="class_user.html">User</a>* user, string_list &amp;results);
<a name="l01072"></a>01072 
<a name="l01079"></a>01079         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnChangeLocalUserHost(<a class="code" href="class_local_user.html">LocalUser</a>* user, <span class="keyword">const</span> std::string &amp;newhost);
<a name="l01080"></a>01080 
<a name="l01087"></a>01087         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnChangeLocalUserGECOS(<a class="code" href="class_local_user.html">LocalUser</a>* user, <span class="keyword">const</span> std::string &amp;newhost);
<a name="l01088"></a>01088 
<a name="l01097"></a>01097         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnPreTopicChange(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan, <span class="keyword">const</span> std::string &amp;topic);
<a name="l01098"></a>01098 
<a name="l01105"></a>01105         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnPostTopicChange(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_channel.html">Channel</a>* chan, <span class="keyword">const</span> std::string &amp;topic);
<a name="l01106"></a>01106 
<a name="l01111"></a>01111         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnEvent(<a class="code" href="class_event.html">Event</a>&amp; event);
<a name="l01112"></a>01112 
<a name="l01117"></a>01117         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnRequest(<a class="code" href="class_request.html">Request</a>&amp; request);
<a name="l01118"></a>01118 
<a name="l01129"></a>01129         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnPassCompare(<a class="code" href="class_extensible.html">Extensible</a>* ex, <span class="keyword">const</span> std::string &amp;password, <span class="keyword">const</span> std::string &amp;input, <span class="keyword">const</span> std::string&amp; hashtype);
<a name="l01130"></a>01130 
<a name="l01137"></a>01137         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnGlobalOper(<a class="code" href="class_user.html">User</a>* user);
<a name="l01138"></a>01138 
<a name="l01145"></a>01145         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnPostConnect(<a class="code" href="class_user.html">User</a>* user);
<a name="l01146"></a>01146 
<a name="l01154"></a>01154         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnAddBan(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_channel.html">Channel</a>* channel,<span class="keyword">const</span> std::string &amp;banmask);
<a name="l01155"></a>01155 
<a name="l01163"></a>01163         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnDelBan(<a class="code" href="class_user.html">User</a>* source, <a class="code" href="class_channel.html">Channel</a>* channel,<span class="keyword">const</span> std::string &amp;banmask);
<a name="l01164"></a>01164 
<a name="l01169"></a>01169         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnHookIO(<a class="code" href="class_stream_socket.html">StreamSocket</a>*, <a class="code" href="class_listen_socket.html">ListenSocket</a>* via);
<a name="l01170"></a>01170 
<a name="l01178"></a>01178         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnAcceptConnection(<span class="keywordtype">int</span> fd, <a class="code" href="class_listen_socket.html">ListenSocket</a>* from, <a class="code" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a>* client, <a class="code" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a>* server);
<a name="l01179"></a>01179 
<a name="l01190"></a>01190         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnStreamSocketAccept(<a class="code" href="class_stream_socket.html">StreamSocket</a>*, <a class="code" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a>* client, <a class="code" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a>* server);
<a name="l01191"></a>01191 
<a name="l01200"></a>01200         <span class="keyword">virtual</span> <span class="keywordtype">int</span> OnStreamSocketWrite(<a class="code" href="class_stream_socket.html">StreamSocket</a>*, std::string&amp; sendq);
<a name="l01201"></a>01201 
<a name="l01206"></a>01206         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnStreamSocketClose(<a class="code" href="class_stream_socket.html">StreamSocket</a>*);
<a name="l01207"></a>01207 
<a name="l01212"></a>01212         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnStreamSocketConnect(<a class="code" href="class_stream_socket.html">StreamSocket</a>*);
<a name="l01213"></a>01213 
<a name="l01221"></a>01221         <span class="keyword">virtual</span> <span class="keywordtype">int</span> OnStreamSocketRead(<a class="code" href="class_stream_socket.html">StreamSocket</a>*, std::string&amp; recvq);
<a name="l01222"></a>01222 
<a name="l01231"></a>01231         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnSetAway(<a class="code" href="class_user.html">User</a>* user, <span class="keyword">const</span> std::string &amp;awaymsg);
<a name="l01232"></a>01232 
<a name="l01244"></a>01244         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnWhoisLine(<a class="code" href="class_user.html">User</a>* user, <a class="code" href="class_user.html">User</a>* dest, <span class="keywordtype">int</span> &amp;numeric, std::string &amp;text);
<a name="l01245"></a>01245 
<a name="l01251"></a>01251         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnGarbageCollect();
<a name="l01252"></a>01252 
<a name="l01257"></a>01257         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnSetConnectClass(<a class="code" href="class_local_user.html">LocalUser</a>* user, <a class="code" href="struct_connect_class.html">ConnectClass</a>* myclass);
<a name="l01258"></a>01258 
<a name="l01262"></a>01262         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnRunTestSuite();
<a name="l01263"></a>01263 
<a name="l01268"></a>01268         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnNamesListItem(<a class="code" href="class_user.html">User</a>* issuer, <a class="code" href="class_membership.html">Membership</a>* item, std::string &amp;prefixes, std::string &amp;nick);
<a name="l01269"></a>01269 
<a name="l01270"></a>01270         <span class="keyword">virtual</span> <a class="code" href="struct_mod_result.html">ModResult</a> OnNumeric(<a class="code" href="class_user.html">User</a>* user, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numeric, <span class="keyword">const</span> std::string &amp;text);
<a name="l01271"></a>01271 
<a name="l01278"></a>01278         <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnSendWhoLine(<a class="code" href="class_user.html">User</a>* source, <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; params, <a class="code" href="class_user.html">User</a>* user, std::string&amp; line);
<a name="l01279"></a>01279 };
<a name="l01280"></a>01280 
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 <span class="preprocessor">#define CONF_NO_ERROR           0x000000</span>
<a name="l01283"></a>01283 <span class="preprocessor"></span><span class="preprocessor">#define CONF_NOT_A_NUMBER       0x000010</span>
<a name="l01284"></a>01284 <span class="preprocessor"></span><span class="preprocessor">#define CONF_INT_NEGATIVE       0x000080</span>
<a name="l01285"></a>01285 <span class="preprocessor"></span><span class="preprocessor">#define CONF_VALUE_NOT_FOUND    0x000100</span>
<a name="l01286"></a>01286 <span class="preprocessor"></span><span class="preprocessor">#define CONF_FILE_NOT_FOUND     0x000200</span>
<a name="l01287"></a>01287 <span class="preprocessor"></span>
<a name="l01288"></a>01288 
<a name="l01295"></a><a class="code" href="class_config_reader.html">01295</a> <span class="keyword">class </span>CoreExport <a class="code" href="class_config_reader.html">ConfigReader</a> : <span class="keyword">public</span> <a class="code" href="classinterfacebase.html">interfacebase</a>
<a name="l01296"></a>01296 {
<a name="l01297"></a>01297   <span class="keyword">protected</span>:
<a name="l01300"></a><a class="code" href="class_config_reader.html#a63c20cb05ab570afb0bb4ae69293ccb6">01300</a>         <span class="keywordtype">long</span> <a class="code" href="class_config_reader.html#a63c20cb05ab570afb0bb4ae69293ccb6">error</a>;
<a name="l01301"></a>01301 
<a name="l01302"></a>01302   <span class="keyword">public</span>:
<a name="l01307"></a>01307         <a class="code" href="class_config_reader.html">ConfigReader</a>();
<a name="l01311"></a>01311         ~<a class="code" href="class_config_reader.html">ConfigReader</a>();
<a name="l01312"></a>01312 
<a name="l01317"></a>01317         std::string ReadValue(<span class="keyword">const</span> std::string &amp;tag, <span class="keyword">const</span> std::string &amp;name, <span class="keywordtype">int</span> index, <span class="keywordtype">bool</span> allow_linefeeds = <span class="keyword">false</span>);
<a name="l01323"></a>01323         std::string ReadValue(<span class="keyword">const</span> std::string &amp;tag, <span class="keyword">const</span> std::string &amp;name, <span class="keyword">const</span> std::string &amp;default_value, <span class="keywordtype">int</span> index, <span class="keywordtype">bool</span> allow_linefeeds = <span class="keyword">false</span>);
<a name="l01324"></a>01324 
<a name="l01330"></a>01330         <span class="keywordtype">bool</span> ReadFlag(<span class="keyword">const</span> std::string &amp;tag, <span class="keyword">const</span> std::string &amp;name, <span class="keywordtype">int</span> index);
<a name="l01337"></a>01337         <span class="keywordtype">bool</span> ReadFlag(<span class="keyword">const</span> std::string &amp;tag, <span class="keyword">const</span> std::string &amp;name, <span class="keyword">const</span> std::string &amp;default_value, <span class="keywordtype">int</span> index);
<a name="l01338"></a>01338 
<a name="l01348"></a>01348         <span class="keywordtype">int</span> ReadInteger(<span class="keyword">const</span> std::string &amp;tag, <span class="keyword">const</span> std::string &amp;name, <span class="keywordtype">int</span> index, <span class="keywordtype">bool</span> need_positive);
<a name="l01357"></a>01357         <span class="keywordtype">int</span> ReadInteger(<span class="keyword">const</span> std::string &amp;tag, <span class="keyword">const</span> std::string &amp;name, <span class="keyword">const</span> std::string &amp;default_value, <span class="keywordtype">int</span> index, <span class="keywordtype">bool</span> need_positive);
<a name="l01358"></a>01358 
<a name="l01363"></a>01363         <span class="keywordtype">long</span> GetError();
<a name="l01364"></a>01364 
<a name="l01371"></a>01371         <span class="keywordtype">int</span> Enumerate(<span class="keyword">const</span> std::string &amp;tag);
<a name="l01372"></a>01372 };
<a name="l01373"></a>01373 
<a name="l01374"></a>01374 
<a name="l01375"></a>01375 
<a name="l01381"></a><a class="code" href="class_file_reader.html">01381</a> <span class="keyword">class </span>CoreExport <a class="code" href="class_file_reader.html">FileReader</a> : <span class="keyword">public</span> <a class="code" href="classclassbase.html">classbase</a>
<a name="l01382"></a>01382 {
<a name="l01385"></a>01385         std::vector&lt;std::string&gt; fc;
<a name="l01386"></a>01386 
<a name="l01389"></a>01389         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> contentsize;
<a name="l01390"></a>01390 
<a name="l01393"></a>01393         <span class="keywordtype">void</span> CalcSize();
<a name="l01394"></a>01394 
<a name="l01395"></a>01395  <span class="keyword">public</span>:
<a name="l01400"></a>01400         <a class="code" href="class_file_reader.html">FileReader</a>();
<a name="l01401"></a>01401 
<a name="l01407"></a>01407         <a class="code" href="class_file_reader.html">FileReader</a>(<span class="keyword">const</span> std::string &amp;filename);
<a name="l01408"></a>01408 
<a name="l01412"></a>01412         ~<a class="code" href="class_file_reader.html">FileReader</a>();
<a name="l01413"></a>01413 
<a name="l01419"></a>01419         <span class="keywordtype">void</span> LoadFile(<span class="keyword">const</span> std::string &amp;filename);
<a name="l01420"></a>01420 
<a name="l01423"></a>01423         std::string Contents();
<a name="l01424"></a>01424 
<a name="l01427"></a>01427         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ContentSize();
<a name="l01428"></a>01428 
<a name="l01432"></a>01432         <span class="keywordtype">bool</span> Exists();
<a name="l01433"></a>01433 
<a name="l01438"></a>01438         std::string GetLine(<span class="keywordtype">int</span> x);
<a name="l01439"></a>01439 
<a name="l01445"></a>01445         <span class="keywordtype">int</span> FileSize();
<a name="l01446"></a>01446 };
<a name="l01447"></a>01447 
<a name="l01450"></a>01450 <span class="keyword">typedef</span> std::vector&lt;Module*&gt; IntModuleList;
<a name="l01451"></a>01451 
<a name="l01454"></a>01454 <span class="keyword">typedef</span> IntModuleList::iterator EventHandlerIter;
<a name="l01455"></a>01455 
<a name="l01459"></a><a class="code" href="class_module_manager.html">01459</a> <span class="keyword">class </span>CoreExport <a class="code" href="class_module_manager.html">ModuleManager</a>
<a name="l01460"></a>01460 {
<a name="l01461"></a>01461  <span class="keyword">private</span>:
<a name="l01464"></a>01464         std::string LastModuleError;
<a name="l01465"></a>01465 
<a name="l01468"></a>01468         <span class="keywordtype">int</span> ModCount;
<a name="l01469"></a>01469 
<a name="l01473"></a>01473         std::map&lt;std::string, Module*&gt; Modules;
<a name="l01474"></a>01474 
<a name="l01475"></a>01475         <span class="keyword">enum</span> {
<a name="l01476"></a>01476                 PRIO_STATE_FIRST,
<a name="l01477"></a>01477                 PRIO_STATE_AGAIN,
<a name="l01478"></a>01478                 PRIO_STATE_LAST
<a name="l01479"></a>01479         } prioritizationState;
<a name="l01480"></a>01480 
<a name="l01482"></a>01482         <span class="keywordtype">bool</span> CanUnload(<a class="code" href="class_module.html">Module</a>*);
<a name="l01483"></a>01483  <span class="keyword">public</span>:
<a name="l01484"></a>01484 
<a name="l01488"></a><a class="code" href="class_module_manager.html#a099599c85a6e8abf11230cf9c9c92ce0">01488</a>         IntModuleList EventHandlers[I_END];
<a name="l01489"></a>01489 
<a name="l01491"></a><a class="code" href="class_module_manager.html#a6456bd6f817cf59565f41d81344c40b0">01491</a>         std::multimap&lt;std::string, ServiceProvider*&gt; <a class="code" href="class_module_manager.html#a6456bd6f817cf59565f41d81344c40b0">DataProviders</a>;
<a name="l01492"></a>01492 
<a name="l01495"></a>01495         <a class="code" href="class_module_manager.html">ModuleManager</a>();
<a name="l01496"></a>01496 
<a name="l01499"></a>01499         ~<a class="code" href="class_module_manager.html">ModuleManager</a>();
<a name="l01500"></a>01500 
<a name="l01517"></a>01517         <span class="keywordtype">bool</span> SetPriority(<a class="code" href="class_module.html">Module</a>* mod, Implementation i, Priority s, <a class="code" href="class_module.html">Module</a>* which = NULL);
<a name="l01518"></a>01518 
<a name="l01520"></a><a class="code" href="class_module_manager.html#a3e3e7c2078327d4f2daba585408db5d5">01520</a>         <span class="keyword">inline</span> <span class="keywordtype">bool</span> SetPriority(<a class="code" href="class_module.html">Module</a>* mod, Implementation i, Priority s, <a class="code" href="class_module.html">Module</a>** dptr)
<a name="l01521"></a>01521         {
<a name="l01522"></a>01522                 <span class="keywordflow">return</span> SetPriority(mod, i, s, *dptr);
<a name="l01523"></a>01523         }
<a name="l01524"></a>01524 
<a name="l01533"></a>01533         <span class="keywordtype">bool</span> SetPriority(<a class="code" href="class_module.html">Module</a>* mod, Priority s);
<a name="l01534"></a>01534 
<a name="l01542"></a>01542         <span class="keywordtype">bool</span> Attach(Implementation i, <a class="code" href="class_module.html">Module</a>* mod);
<a name="l01543"></a>01543 
<a name="l01551"></a>01551         <span class="keywordtype">bool</span> Detach(Implementation i, <a class="code" href="class_module.html">Module</a>* mod);
<a name="l01552"></a>01552 
<a name="l01557"></a>01557         <span class="keywordtype">void</span> Attach(Implementation* i, <a class="code" href="class_module.html">Module</a>* mod, <span class="keywordtype">size_t</span> sz);
<a name="l01558"></a>01558 
<a name="l01562"></a>01562         <span class="keywordtype">void</span> DetachAll(<a class="code" href="class_module.html">Module</a>* mod);
<a name="l01563"></a>01563 
<a name="l01567"></a>01567         std::string&amp; LastError();
<a name="l01568"></a>01568 
<a name="l01574"></a>01574         <span class="keywordtype">bool</span> Load(<span class="keyword">const</span> std::string&amp; filename, <span class="keywordtype">bool</span> defer = <span class="keyword">false</span>);
<a name="l01575"></a>01575 
<a name="l01581"></a>01581         <span class="keywordtype">bool</span> Unload(<a class="code" href="class_module.html">Module</a>* module);
<a name="l01582"></a>01582 
<a name="l01587"></a>01587         <span class="keywordtype">void</span> Reload(<a class="code" href="class_module.html">Module</a>* module, <a class="code" href="class_handler_base1.html">HandlerBase1&lt;void, bool&gt;</a>* callback);
<a name="l01588"></a>01588 
<a name="l01591"></a>01591         <span class="keywordtype">void</span> LoadAll();
<a name="l01592"></a>01592         <span class="keywordtype">void</span> UnloadAll();
<a name="l01593"></a>01593         <span class="keywordtype">void</span> DoSafeUnload(<a class="code" href="class_module.html">Module</a>*);
<a name="l01594"></a>01594 
<a name="l01598"></a><a class="code" href="class_module_manager.html#a56edb0c2cb0f7ebd41c90cdaf64e23db">01598</a>         <span class="keywordtype">int</span> GetCount()
<a name="l01599"></a>01599         {
<a name="l01600"></a>01600                 <span class="keywordflow">return</span> this-&gt;ModCount;
<a name="l01601"></a>01601         }
<a name="l01602"></a>01602 
<a name="l01608"></a>01608         <a class="code" href="class_module.html">Module</a>* Find(<span class="keyword">const</span> std::string &amp;name);
<a name="l01609"></a>01609 
<a name="l01611"></a>01611         <span class="keywordtype">void</span> AddService(<a class="code" href="class_service_provider.html">ServiceProvider</a>&amp;);
<a name="l01612"></a>01612 
<a name="l01614"></a>01614         <span class="keywordtype">void</span> DelService(<a class="code" href="class_service_provider.html">ServiceProvider</a>&amp;);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616         <span class="keyword">inline</span> <span class="keywordtype">void</span> AddServices(<a class="code" href="class_service_provider.html">ServiceProvider</a>** list, <span class="keywordtype">int</span> count)
<a name="l01617"></a>01617         {
<a name="l01618"></a>01618                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; count; i++)
<a name="l01619"></a>01619                         AddService(*list[i]);
<a name="l01620"></a>01620         }
<a name="l01621"></a>01621 
<a name="l01625"></a>01625         <a class="code" href="class_service_provider.html">ServiceProvider</a>* FindService(ServiceType Type, <span class="keyword">const</span> std::string&amp; name);
<a name="l01626"></a>01626 
<a name="l01627"></a>01627         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T* FindDataService(<span class="keyword">const</span> std::string&amp; name)
<a name="l01628"></a>01628         {
<a name="l01629"></a>01629                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(FindService(SERVICE_DATA, name));
<a name="l01630"></a>01630         }
<a name="l01631"></a>01631 
<a name="l01638"></a>01638         <span class="keyword">const</span> std::vector&lt;std::string&gt; GetAllModuleNames(<span class="keywordtype">int</span> filter);
<a name="l01639"></a>01639 };
<a name="l01640"></a>01640 
<a name="l01644"></a>01644 <span class="preprocessor">#define MODULE_INIT_STR MODULE_INIT_STR_FN_2(MODULE_INIT_SYM)</span>
<a name="l01645"></a>01645 <span class="preprocessor"></span><span class="preprocessor">#define MODULE_INIT_STR_FN_2(x) MODULE_INIT_STR_FN_1(x)</span>
<a name="l01646"></a>01646 <span class="preprocessor"></span><span class="preprocessor">#define MODULE_INIT_STR_FN_1(x) #x</span>
<a name="l01647"></a>01647 <span class="preprocessor"></span><span class="preprocessor">#define MODULE_INIT_SYM MODULE_INIT_SYM_FN_2(INSPIRCD_VERSION_MAJ, INSPIRCD_VERSION_API)</span>
<a name="l01648"></a>01648 <span class="preprocessor"></span><span class="preprocessor">#define MODULE_INIT_SYM_FN_2(x,y) MODULE_INIT_SYM_FN_1(x,y)</span>
<a name="l01649"></a>01649 <span class="preprocessor"></span><span class="preprocessor">#define MODULE_INIT_SYM_FN_1(x,y) inspircd_module_ ## x ## _ ## y</span>
<a name="l01650"></a>01650 <span class="preprocessor"></span>
<a name="l01651"></a>01651 <span class="preprocessor">#ifdef PURE_STATIC</span>
<a name="l01652"></a>01652 <span class="preprocessor"></span>
<a name="l01653"></a>01653 <span class="keyword">struct </span>AllCommandList {
<a name="l01654"></a>01654         <span class="keyword">typedef</span> <a class="code" href="class_command.html">Command</a>* (*fn)(<a class="code" href="class_module.html">Module</a>*);
<a name="l01655"></a>01655         AllCommandList(fn cmd);
<a name="l01656"></a>01656 };
<a name="l01657"></a>01657 <span class="preprocessor">#define COMMAND_INIT(x) static Command* MK_ ## x(Module* m) { return new x(m); } \</span>
<a name="l01658"></a>01658 <span class="preprocessor">        static const AllCommandList PREP_ ## x(&amp;MK_ ## x);</span>
<a name="l01659"></a>01659 <span class="preprocessor"></span>
<a name="l01660"></a>01660 <span class="keyword">struct </span>AllModuleList {
<a name="l01661"></a>01661         <span class="keyword">typedef</span> <a class="code" href="class_module.html">Module</a>* (*fn)();
<a name="l01662"></a>01662         fn init;
<a name="l01663"></a>01663         std::string name;
<a name="l01664"></a>01664         AllModuleList(fn mod, <span class="keyword">const</span> std::string&amp; Name);
<a name="l01665"></a>01665 };
<a name="l01666"></a>01666 
<a name="l01667"></a>01667 <span class="preprocessor">#define MODULE_INIT(x) static Module* MK_ ## x() { return new x; } \</span>
<a name="l01668"></a>01668 <span class="preprocessor">        static const AllModuleList PREP_ ## x(&amp;MK_ ## x, MODNAMESTR);</span>
<a name="l01669"></a>01669 <span class="preprocessor"></span>
<a name="l01670"></a>01670 <span class="preprocessor">#define MODNAMESTR MODNAMESTR_FN_2(MODNAME)</span>
<a name="l01671"></a>01671 <span class="preprocessor"></span><span class="preprocessor">#define MODNAMESTR_FN_2(x) MODNAMESTR_FN_1(x)</span>
<a name="l01672"></a>01672 <span class="preprocessor"></span><span class="preprocessor">#define MODNAMESTR_FN_1(x) #x</span>
<a name="l01673"></a>01673 <span class="preprocessor"></span>
<a name="l01674"></a>01674 <span class="preprocessor">#else</span>
<a name="l01675"></a>01675 <span class="preprocessor"></span>
<a name="l01680"></a>01680 <span class="preprocessor">#ifdef WINDOWS</span>
<a name="l01681"></a>01681 <span class="preprocessor"></span>
<a name="l01682"></a>01682 <span class="preprocessor">#define MODULE_INIT(y) \</span>
<a name="l01683"></a>01683 <span class="preprocessor">        extern &quot;C&quot; DllExport Module * MODULE_INIT_SYM() \</span>
<a name="l01684"></a>01684 <span class="preprocessor">        { \</span>
<a name="l01685"></a>01685 <span class="preprocessor">                return new y; \</span>
<a name="l01686"></a>01686 <span class="preprocessor">        } \</span>
<a name="l01687"></a>01687 <span class="preprocessor">        BOOLEAN WINAPI DllMain(HINSTANCE hDllHandle, DWORD nReason, LPVOID Reserved) \</span>
<a name="l01688"></a>01688 <span class="preprocessor">        { \</span>
<a name="l01689"></a>01689 <span class="preprocessor">                switch ( nReason ) \</span>
<a name="l01690"></a>01690 <span class="preprocessor">                { \</span>
<a name="l01691"></a>01691 <span class="preprocessor">                        case DLL_PROCESS_ATTACH: \</span>
<a name="l01692"></a>01692 <span class="preprocessor">                        case DLL_PROCESS_DETACH: \</span>
<a name="l01693"></a>01693 <span class="preprocessor">                                break; \</span>
<a name="l01694"></a>01694 <span class="preprocessor">                } \</span>
<a name="l01695"></a>01695 <span class="preprocessor">                return TRUE; \</span>
<a name="l01696"></a>01696 <span class="preprocessor">        }</span>
<a name="l01697"></a>01697 <span class="preprocessor"></span>
<a name="l01698"></a>01698 <span class="preprocessor">#else</span>
<a name="l01699"></a>01699 <span class="preprocessor"></span>
<a name="l01700"></a>01700 <span class="preprocessor">#define MODULE_INIT(y) \</span>
<a name="l01701"></a>01701 <span class="preprocessor">        extern &quot;C&quot; DllExport Module * MODULE_INIT_SYM() \</span>
<a name="l01702"></a>01702 <span class="preprocessor">        { \</span>
<a name="l01703"></a>01703 <span class="preprocessor">                return new y; \</span>
<a name="l01704"></a>01704 <span class="preprocessor">        } \</span>
<a name="l01705"></a>01705 <span class="preprocessor">        extern &quot;C&quot; const char inspircd_src_version[] = VERSION &quot; r&quot; REVISION;</span>
<a name="l01706"></a>01706 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01707"></a>01707 <span class="preprocessor"></span>
<a name="l01708"></a>01708 <span class="preprocessor">#define COMMAND_INIT(c) MODULE_INIT(CommandModule&lt;c&gt;)</span>
<a name="l01709"></a>01709 <span class="preprocessor"></span>
<a name="l01710"></a>01710 <span class="preprocessor">#endif</span>
<a name="l01711"></a>01711 <span class="preprocessor"></span>
<a name="l01712"></a>01712 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
